<?xml version="1.0"?>
<abiword version="unnumbered"  fileformat="1.0">
<!-- =====================================================================  -->
<!-- This file is an AbiWord document.                                      -->
<!-- AbiWord is a free, Open Source word processor.                         -->
<!-- You may obtain more information about AbiWord at www.abisource.com     -->
<!-- You should not edit this file by hand.                                 -->
<!-- =====================================================================  -->

<!--         Build_ID          = (none) -->
<!--         Build_Version     = unnumbered -->
<!--         Build_Options     = LicensedTrademarks:Off Debug:Off BiDi:Off Bonobo:Off DirectPrint:On Gnome:On LibXML:Off Pspell:Off -->
<!--         Build_Target      = /tmp/21506-i386/BUILD/abi/src/Linux_2.4.5-10enterprise_i386_GNOME/obj -->
<!--         Build_CompileTime = 06:48:29 -->
<!--         Build_CompileDate = Jul 19 2001 -->

<ignoredwords>
<iw>Initially</iw>
</ignoredwords>
<pagesize pagetype="Letter" orientation="portrait" width="8.500000" height="11.000000" units="inch" page-scale="1.000000"/>
<section header="1800114746">
<p>An Alternative UNIX Directory Structure</p>
<p></p>
<p>Introduction</p>
<p></p>
<p>The UNIX operating system was first used on environments where users accessed a central application server through terminal stations with low (or no) storage capacity. A number of characteristics of this system, most notably the data organization structured as a directory tree, reflect this history. The storage model based on trees proves to be adequate to this day; however, the logic behind the UNIX directory hierarchy is based on premises that no longer correspond to the reality of the most existing Linux installations. The Linux operating system is getting wider use on personal stations which execute and store the user’s applications. In this context, there is no “application server”, and still, conventions such as the existence of different repositories for libraries persist (/lib, /usr/lib and /usr/local/lib).</p>
<p>Because of the fast pace of development in the Free Software community ( “release early, release often” ), the process of installing and removing programs became common and frequent. This is very different from the scenario on which the criteria for the UNIX directory hierarchy (still used by the Linux distributions) were based upon. These criteria do not take into account the needs of today’s reality; it becomes interesting to reevaluate them and seek an alternative.</p>
<p>This paper presents a directory tree that was conceived from the needs and usage patterns of modern Linux systems and retains compatibility with the UNIX legacy. Initially, aspects of the classic hierarchy are discussed (Section 2). Next, an overview of the approaches employed in directory trees of other systems is presented (Section 3). Section 4 describes the devised hierarchy, while Section 5 report experiences related to the use of this model. Finally, Section 6 concludes the paper.</p>
<p></p>
<p>Characteristics of the current hierarchy</p>
<p></p>
<p>In the UNIX tree, directories serve two purposes: differentiate categories of files and differentiate their location in the network. Files of the “executable” category from all applications are stored in six directories: /bin, /usr/bin, /usr/local/bin, /sbin, /usr/sbin and /usr/local/sbin [files from the X Window System are, historically, an exception to this rule, possessing an entire UNIX-like hierarchy under /usr/X11R6], where the criteria of choice to determine which of those six directories is used for a given file is its physical location (local or remote). Still, some programs are installed in other locations than those dictated by the above rules. For instance, the File System Hierarchy standard has an arbitrary list of which executable files should be stored at the /bin directory.</p>
<p>Some programs assume that certain files are stored in specific locations (for example, /lib/cpp, /usr/bin/python). This is a source of incompatibilities, even between different Linux distributions that follow the traditional model of directories. But the biggest problem caused by this approach is the difficulty in the removal of programs, since files of different applications are mixed in the same directories and different files from a single application are spread throughout a number of directories.</p>
<p>The solution used by companies and organizations that develop Linux distributions in order to maintain a correspondence between individual files and applications is “package managing”, that is, installing and removing software using a program that maintains a database that relates existing files in the system to the applications from which they were originated. The main limitation of this method is the fact that installation of applications from source code generates inconsistencies in the database.</p>
<p>A common practice is to keep the /usr hierarchy maintained by the package manager and target the installation of programs compiled locally to /usr/local. This keeps the database consistent, but does not solve the issue on how to remove programs installed from source.</p>
<p>The  UNIX hierarchy standard defined an extra directory, /opt, to allow groups of applications to be installed separately from the rest. This can be considered an acknowledgment of the existence of the problems enumerated above. Even so, this causes a conflict of criteria in the standard itself.</p>
<p></p>
<p>Alternative approaches</p>
<p></p>
<p>Practically all operating systems developed after UNIX use the model of directory trees. The different organizations applied to the directory hierarchy of those systems reflect the changes both in the way how computers are used and in their storage capacity. Below, we describe the directory trees existing in Mac OS X and AtheOS, desktop operating systems that possess a certain degree of UNIX heritage.</p>
<p>The adoption of a kernel and tools based, respectively, on Mach 3.0 and FreeBSD brought to Apple Computer the challenge to combine the UNIX hierarchy with a look and feel familiar to Mac OS users. Mac OS X uses an uncommon strategy to achieve this feat. In the graphical interface, a Macintosh directory tree is presented, containing directories such as /System/Library and /Network/Remote_Station. Actually, these directories are a subset of the real directory tree. Also, the interface displays some directories in locations other than their physical storage points. For instance, /Mac OS X is a link to the root directory, and some directories, such as /Applications, appear in the interface as /Mac OS X/Applications. Accessing the file system through a text-based shell, “hidden” UNIX directories such as /usr and /etc become accessible. Note that this approach is only possible in a proprietary environment, where the user interface of the system is developed by a single company. In a system like Linux, this would be impossible, given the heterogeneity of graphical user interfaces available.</p>
<p>The directory hierarchy of the AtheOS operating system is partially based on the UNIX tree. In AtheOS, for example, the /usr directory is used for the intents that, in UNIX, /opt is used. This is made possible by the establish of the <c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">^ directory convention. The AtheOS libraries recognize this as the “directory where the currently running executable file resides”, analogously as ~, the UNIX indicator to the user’s home directory. Unfortunately, Linux being a UNIX clone, cannot employ solutions as this one, since this causes considerable portability problems (a text-based Linux application can be easily ported to AtheOS, but the opposite is not true).</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">There are programs that try to present alternatives to provide, to some degree, a reorganization of the directory hierarchy. Two of the most used programs of this kind are GNU Stow and Encap. Both follow the basic idea presented by the Depot software, developed at Carnegie Mellon. The principle is to maintain two directory trees: a “real” one, where the files are sorted by application; and another one, sorted in the traditional way, containing links to the files located at the first tree [The AtheOS operating system uses a similar technique to maintain compatibility with UNIX applications]. GNU Stow intends to be a simplified alternative to Depot, since, contrary to Depot, it does not maintain a database. When using Stow, the application should be compiled with paths relative to /usr/local and installed with paths relative to /usr/local/stow/application. Encap uses similar systematics, with a rudimentary support for version control (the package manager software, epkg, tries to detect versions through the name of the application created under /usr/local/encap, for example, sed-2.0 and sed-3.0.2).</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">The GoboLinux hierarchy</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">The basic idea behind the GoboLinux hierarchy is to combine ideas from the previously presented operating systems and the link system introduced by Depot, creating a new hierarchy that maintains total compatibility with the UNIX tree. Like in Depot, each program (Gimp, Fileutils, Glibc, Qt, etc.) is installed in its entirety inside a separate directory. Inside this directory, standard UNIX directories are typically created, containing the files that in the traditional UNIX directory tree would be copied to /usr/bin (or /bin), /usr/sbin (or /sbin), /usr/lib (or /lib), and so on.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">For this purpose, a /Programs directory was estabilished, containing a subdirectory for each installed program. Each of those subdirectories has, on its turn, a subdirectory for each version of the specific program, and a link labeled Current pointing to the currently used version. Each program also has a Settings directory storing the program’s configuration files (which would be normally stored at /etc). Notice that this directory is unique for all versions of the program. This design choice eases the version control, since the personal configurations are preserved in the event of an upgrade or downgrade.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Installation of programs from source is made through scripts. In the case of programs with configuration files generated using GNU autoconf (which is the majority of free software packages) the script uses the --prefix parameter to define the destination of the files being installed. For example, when installing the Qt library, version 2.3.2, the command configure --prefix=/Programs/Qt/2.3.3 is automatically executed, and the required directories are created. For programs that don’t provide this parameter in their configuration files, the configure script (or the Makefiles themselves) will be adjusted, automatically, through scripts that attempt to replace the paths contained in the file; or, in a few cases, manually.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Once a new version of a program is installed, links are created from each file in the application at directories that centralize those links according to file types. For example, /System/Links/Executables stores links for executable files of all programs (contained in the bin and sbin directories). This way, all executables can be called or accessed from a single directory (same happening to th libraries, headers and manuals / info files). This approach is different from the ones used by the symbolic link management systems discussed on Section 3, as the generated links structure does not reflect the UNIX hierarchy, but a functional categorization of the links.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Figure 1 describes in greater detail the general directory hierarchy as proposed. An important treat of this structure is the nonexistence of a global share directory (programs can have their own share directories). This decision is explained by the fact that, even though the share directory permits sharing of data between different applications, in practice this directory serves a repository for application-specific files that has no place on the UNIX hierarchy (such as icons and fonts). This way, we opted not to have a /System/Links/Shared directory, because the different share directories of each application have no relation between them.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Compatibility with the UNIX legacy is obtained through creation of extra links not present in the above diagram, such as /etc -&gt; /System/Settings, /bin -&gt; /System/Links/Executables and /lib -&gt; /System/Links/Libraries, mirroring the GoboLinux tree into the UNIX tree. Unlike previous proposals that attempted to organize the directory tree maintaining historical compatibility, in GoboLinux there is a single point for installation of programs, without a legacy tree in parallel.</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Experience</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Practical experience with the directory structure presented in this paper can be divided in two parts. Firstly, the project was started off with a package based distribution which was gradually converted to the GoboLinux tree as the programs were updated to new versions. In this stage, structural ideas evolved and their validity and viability were verified.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">In a second stage, we opted to compile the entire system following the GoboLinux hierarchy, intending to have total control of all files installed in the machine. For such, we used as a basis the documentation created by the "Linux from Scratch” project.</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Concluding remarks</c></p>
<p></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">As presented in Section 3, the search for alternatives to reorganize the UNIX directory tree is a subject of several projects. This paper presented a new proposition for the UNIX directory structure, differing from previously existing projects mainly because there is no legacy tree coexisting with the main tree, allowing for a greater self-consistency and elegance. Practical experience showed the total viability and compatibility of the presented ideas, as well as making evident the benefits brought by this new structure.</c></p>
<p><c props="color:000000; font-family:Times New Roman; font-size:12pt; font-style:normal; font-weight:normal; text-decoration:none; text-position:normal">Further information about GoboLinux can be obtained at http://cscience.org/~gobo.</c></p>
<p></p>
</section>
<section id="1800114746" listid="0" parentid="0" type="header">
<p style="Normal" props="text-align:left"></p>
</section>
</abiword>
